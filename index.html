<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Carte des piscines par département</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
  <style>
    #map {
      height: 600px;
    }
    #controls {
      margin: 10px;
      position: absolute;
      z-index: 500;
    }

    br {
      color: lightgray;
    }
  </style>
</head>
<body>
  <div id="controls">
    <select id="mode-select">
      <option value="driving">En voiture</option>
      <option value="cycling">En vélo</option>
      <option value="walking">À pied</option>
      <option value="driving-traffic">En voiture avec trafic</option>
    </select>
    <input type="number" id="time-input" value="10" min="1" max="60" /> minutes
  </div>
  <div id="map"></div>
  <script>
    const mapboxAccessToken = 'pk.eyJ1IjoiamFtZXNpdGhlYSIsImEiOiJjbG93b2FiaXEwMnVpMmpxYWYzYjBvOTVuIn0.G2rAo0xl14oye9YVz4eBcw';

    const map = L.map('map', {
      zoomSnap: 0.5,
      zoomDelta: 0.5,
      zoomControl: false // Désactiver les contrôles de zoom
    }).setView([46.603354, 1.888334], 6);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 18
    }).addTo(map);

    const modeSelect = document.getElementById('mode-select');
    const timeInput = document.getElementById('time-input');

    let lastClickedLat = null;
    let lastClickedLon = null;
    let selectedCircle = null; // Variable pour stocker le cercle sélectionné
    const circlesLayer = L.layerGroup().addTo(map);

    modeSelect.addEventListener('change', () => {
      if (lastClickedLat && lastClickedLon) {
        updateIsochrone(lastClickedLat, lastClickedLon, modeSelect.value, timeInput.value);
      }
    });

    timeInput.addEventListener('change', () => {
      if (lastClickedLat && lastClickedLon) {
        updateIsochrone(lastClickedLat, lastClickedLon, modeSelect.value, timeInput.value);
      }
    });

    // Charger les données CSV et préparer l'application
    loadCSVData('data-es-piscines-bdn.csv', function(data) {
      const installations = {};

      // Regrouper les équipements par "Numéro de l'installation sportive"
      data.forEach(item => {
        const installationId = item['Numéro de l\'installation sportive'];
        if (!installations[installationId]) {
          installations[installationId] = {
            lat: parseFloat(item['Latitude (WGS84)']),
            lon: parseFloat(item['Longitude (WGS84)']),
            name: item["Nom de l'installation sportive"],
            equipments: []
          };
        }
        installations[installationId].equipments.push({
          name: item["Nom de l'équipement sportif"],
          surface: item["Surface du bassin"]
        });
      });

      // Créer un cercle pour chaque installation
      Object.keys(installations).forEach(id => {
        const installation = installations[id];
        const lat = installation.lat;
        const lon = installation.lon;
        const name = installation.name;
        const equipments = installation.equipments;

        if (!isNaN(lat) && !isNaN(lon)) {
          let tooltipContent = `<b>${name}</b><br>`;
          equipments.forEach(equipment => {
            tooltipContent += `<hr>Équipement: ${equipment.name}<br>Surface: ${equipment.surface} m²`;
          });

          const circle = L.circle([lat, lon], {
            color: '#3388ff',
            radius: 200 // Augmenter le rayon
          }).bindTooltip(tooltipContent, { permanent: false, direction: 'top' });

          circle.on('mouseover', function () {
            circle.openTooltip();
          });

          circle.on('mouseout', function () {
            circle.closeTooltip();
          });

          circle.on('click', function () {
            if (selectedCircle) {
              selectedCircle.setStyle({ color: '#3388ff' }); // Rétablir la couleur d'origine
            }
            circle.setStyle({ color: 'red' }); // Changer la couleur en rouge
            selectedCircle = circle;

            lastClickedLat = lat;
            lastClickedLon = lon;
            updateIsochrone(lat, lon, modeSelect.value, timeInput.value);
          });

          circlesLayer.addLayer(circle);
        }
      });
    });

    function loadCSVData(url, callback) {
      Papa.parse(url, {
        download: true,
        header: true,
        complete: function(results) {
          callback(results.data);
        }
      });
    }

    async function updateIsochrone(lat, lon, mode, minutes) {
      if (map.isochroneLayer) {
        map.removeLayer(map.isochroneLayer);
      }

      const isochrone = await getIsochrone(lat, lon, mode, minutes);
      if (isochrone) {
        map.isochroneLayer = L.geoJSON(isochrone, {
          style: function (feature) {
            return {
              color: '#ff7800',
              weight: 2,
              fillOpacity: 0.3,
              fillColor: '#ff7800'
            };
          }
        }).addTo(map);

        // Centrer la carte sur l'isochrone
        const bounds = map.isochroneLayer.getBounds();
        map.fitBounds(bounds);

        // Amener chaque cercle au premier plan
        circlesLayer.eachLayer(function(layer) {
          layer.bringToFront();
        });
      }
    }

    async function getIsochrone(lat, lon, mode, minutes) {
      const url = `https://api.mapbox.com/isochrone/v1/mapbox/${mode}/${lon},${lat}?contours_minutes=${minutes}&polygons=true&access_token=${mapboxAccessToken}`;
      
      try {
        const response = await axios.get(url);
        return response.data;
      } catch (error) {
        console.error(error);
        return null;
      }
    }
  </script>
</body>
</html>
